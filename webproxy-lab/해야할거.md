# 어떡하지?


- 서버에게 응답을 받으면 그걸 다시 클라이언트에게 보내야 함
  - 텍스트 파일이 아니라 이진 파일일 땐, 다른 접근법이 필요하겠죠.
- 중간에 파일이 짤림.

# 버그없나?
- parse the request
  - e.g., 브라우저가 `GET http://www.cmu.edu/hub/index.html HTTP/1.1`와 같은 요청을 보내면
  - `www.cmu.edu`랑 `/hub/index.html`로 나눔
  - 그리고 `GET /hub/index.html HTTP/1.0`과 같은 요청을 보내야 함

- 포트 번호
  - HTTP requeset port: 받은 GET 요청에 port가 존재하면, 해당 포트 번호로 (80이 아니라)
  - listening port: 프록시가 요청을 듣는 포트. 내 실습에선 8000

- parse한 request 기반으로 보내기
  - 어떻게 보내야 할까?
    - `[method] [suffix] HTTP/1.0`을 보낸다
  - 어디로 보내야 할까?
    - `open_clientfd([prefix], [portNo])`로 소켓식별자를 반환한다.
    - `Rio_writen`으로 보내준다.

- 보내야 하는 request header
  - Host: www.cmu.edu (앞서 request에서 parse하면 됨)
    - 만약 브라우저가 Host를 보내면, 프록시도 동일 Host 헤더를 보냄
  - User-Agent: 제공해 줌
  - Connection: close 필수
  - Proxy-Connection: close 필수
  - 다른 요청도 바꾸지 않고 forward -> 단순히 쓰기 버퍼에 헤더를 넣는 방식으로 해결해보기.
- 실제 클라이언트가 보내는 요청의 형태

```bash
Request headers:
GET /godzilla.gif HTTP/1.1
Connection: keep-alive
sec-ch-ua-platform: "Windows"
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/138.0.0.0 Safari/537.36
sec-ch-ua: "Not)A;Brand";v="8", "Chromium";v="138", "Google Chrome";v="138"
sec-ch-ua-mobile: ?0
Accept: image/avif,image/webp,image/apng,image/svg+xml,image/*,*/*;q=0.8
Sec-Fetch-Site: same-origin
Sec-Fetch-Mode: no-cors
Sec-Fetch-Dest: image
Referer: http://localhost:8000/
Accept-Encoding: gzip, deflate, br, zstd
Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7
```

# 다한거